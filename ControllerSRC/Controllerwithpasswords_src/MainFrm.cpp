// MainFrm.cpp : implementation of the CMainFrame class
//
// Copyright (c) 2014-2015 Nine Tiles

#include "stdafx.h"
#include "Controller.h"
#include "ControllerDoc.h"

#include "MainFrm.h"
#include ".\mainfrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_TIMER()
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};


// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	retry_count = -1;
}

CMainFrame::~CMainFrame()
{
}


int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
		| CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}
	// TODO: Delete these three lines if you don't want the toolbar to be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}


// This picks up the window co-ordinates from the previous time the program was run; 
//		the original version (which I'm fairly sure was generated by Visual Studio) 
//		assumes each value was exactly 4 characters, but the values seem to be 
//		relative to the top left of the main screen so can be less than -999 and 
//		thus take up 5 characters, so I've changed it to be more robust
BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	CString strText;
    strText = theApp.GetProfileString("Window sizes", "Rect");
/*	cs.x = atoi((const char*) strText);
    cs.y = atoi((const char*) strText + 5);
	cs.cx = atoi((const char*) strText + 10) - atoi((const char*) strText);
	cs.cy = atoi((const char*) strText + 15) - atoi((const char*) strText + 5);
	if (cs.cx <= 0 || cs.cy <= 0){
			// there are no registry settings
		cs.cx = 1200;
		cs.cy = 900;
	}*/
	if (sscanf_s(strText, "%d %d %d %d", &cs.x, &cs.y, &cs.cx, &cs.cy) < 4) {
			// there are no registry settings
		cs.x = 0;
		cs.y = 0;
		cs.cx = 1200;
		cs.cy = 900;
	}
	else {
		cs.cx -= cs.x;
		cs.cy -= cs.y;
	}

	return CMDIFrameWnd::PreCreateWindow(cs);
}


// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG


// CMainFrame message handlers

// I think this one was automatically generated by Visual Studio; see 
//		<PreCreateWindow> above 
void CMainFrame::OnDestroy()
{
	WINDOWPLACEMENT wndpl;
	wndpl.length = sizeof(WINDOWPLACEMENT);

	BOOL bRet = GetWindowPlacement(&wndpl);

	CString strText;
	strText.Format("%04d %04d %04d %04d",
				wndpl.rcNormalPosition.left, wndpl.rcNormalPosition.top,
				wndpl.rcNormalPosition.right, wndpl.rcNormalPosition.bottom);
	AfxGetApp()->WriteProfileString("Window sizes", "Rect", strText);
	CMDIFrameWnd::OnDestroy();	
}


// timer tick
void CMainFrame::OnTimer(UINT nIDEvent) 
{
	if (nIDEvent == IDT_500MSEC) {
			// tell each of the <MgtSocket> objects
		int i = (int)theApp.units.GetCount();
		MgtSocket * m;
		while (--i > 0) {
			m = theApp.units.GetAt(i);
				// sanity check on <m> includes look for 0xFEEEFEEE
			if (m && m->state > 0) m->PollAwaitingAck();
		}

			// tell the <LinkSocket> object; if the link has timed out we retry 
			//		immediately
		if (theApp.link_socket->PollKeepalives()) retry_count = 0;

			// <retry_count> is -ve during normal operation; on failure we set it +ve 
			//		and count down and retry when it goes back to -ve; we also set it 
			//		+ve on entry to Requesting state
			// retrying includes deleting the old socket and creating a new one; note 
			//		that we need to keep <theApp.link_socket> valid and non-NULL any 
			//		time a management socket might need it
		if (retry_count < 0) {
			if (theApp.link_socket->state > LINK_ST_MAX_OK) {
					// has just failed: wait 5 sec before retry if sockets stack 
					//		failure, 1 sec else
				retry_count = (theApp.link_socket->state == LINK_ST_FAILED) ? 10 : 2;
			}
			else if (theApp.link_socket->state == LINK_ST_REQ) {
					// have just sent the first Link Request: wait 7 sec before give 
					//		up & retry
				retry_count = 14;
			}

			goto done;
		}

		if (theApp.link_socket->state == LINK_ST_ACTIVE) {
			retry_count = -1;
			goto done;
		}

		retry_count -= 1;
		if (retry_count >= 0) goto done;

			// here on timeout, to replace the link socket
		LinkSocket * skt = new LinkSocket();

			// +++ NOTE: calling skt->Bind(0) after Create fails with WSAEINVAL 
			//		("invalid argument was supplied") in the assembly-code 
			//		part, but Create seems to call Bind(0) anyway; also, doing 
			//		Connect at this point seems to stop the broadcast being sent
		int err; // to hold result of GetLastError() for debug
		unless (skt && skt->Create(0, SOCK_DGRAM, FD_READ | FD_CLOSE)) {
			err = GetLastError(); // for debug
			delete skt;
				// +++ ought really to make the action depend on whether <err> seems 
				//		to be transient or permanent
			retry_count = 20;	// wait 10 secs then try again
			goto done;		// keeping the old socket
		}

			// the king is dead; long live the king
		delete theApp.link_socket;
		theApp.link_socket = skt;

			// now send the Link Request; we don't care whether it succeeded because 
			//		either way we'll want a timeout
			// +++ might think about having different timeouts for failure to send 
			//		the reply and waiting for a response to it, though
		skt->Init();
		retry_count = 14;

		theApp.mib_changed = true;
		theApp.controller_doc->UpdateAllViews(NULL);
	}

done:
	CMDIFrameWnd::OnTimer(nIDEvent);
}
